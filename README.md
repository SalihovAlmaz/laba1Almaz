# laba1Almaz
# READMY | S.A.
__Программа для отрисовки треугольника посредством Open GL__

***
``` 
#include <GL/glew.h>
#include <GL/freeglut.h>
#include <glm/vec3.hpp>
int main(int argc, char* argv[]) {
    ...
```
``` 

glutInit(&argc, argv);
```
_Здесь мы инициализируем GLUT._
***

``` 
glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
```
_Так настраиваются некоторые опции GLUT. GLUT_DOUBLE включает двойную буферизацию.GLUT_RGB	Для отображения графической информации используются 3 компоненты цвета RGB._
***
``` 
glutInitWindowSize(1024, 768);
glutInitWindowPosition(100, 100);
glutCreateWindow("Tutorial 01");
```
_Эти функции задают параметры окна и создают его. Так же мы даем ему заголовок._
***
``` 
glutDisplayFunc(RenderSceneCB);
```
_Здесь мы запускаем функцию для отрисовки._
***
```
GLenum res = glewInit();
if (res != GLEW_OK)
{
    fprintf(stderr, "Error: '%s'\n", glewGetErrorString(res));
    return 1;
}
```
_Теперь мы инициализируем GLEW и проверяем на ошибки. GLUT необходимо инициализировать раньше._
***
```
glm::vec3 Vertices[3];
	Vertices[0] = glm::vec3(1.0f, 1.0f, 0.0f);
	Vertices[1] = glm::vec3(-1.0f, 1.0f, 0.0f);
	Vertices[2] = glm::vec3(0.0f,-1.0f, 0.0f);
```
_Мы создаем массив структуры vec3 из библиотеки <glm/vec3.hpp> и заполняем нужными координатами XYZ для построение треугольника_
***
```
GLuint VBO;
```
_Здесь мы назначаем GLuint в качестве глобальной переменной для хранения указателя на буфер вершин._
***
```
glGenBuffers(1, &VBO);
```
Создание имен объектов буфера. Первый параметр - это количество создаваемых буферных объектов, а второй - это массив, который будет использоваться для хранения имен буферных объектов.
***
```
glBindBuffer(GL_ARRAY_BUFFER, VBO);
```
_Здесь мы связываем VBO  с точкой связывния GL_ARRAY_BUFFER_
***
```
glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);
```
_После связывания нашего объекта, мы наполняем его даннымы
Первый парметр это та  же цель, что и при предыдущей функции. Второй параметр это размер данных в байтах. Третий параметр это это указатель на данные. И четвёртый параметр это флаг, который обозначает использование паттернов для этих данных. Так как мы не собираемся изменять значения буфера, указываем GL_STATIC_DRAW._
***
```
glutMainLoop();
```
_Этот вызов передаёт контроль GLUT'у, который теперь начнёт свой собственный цикл. В этом цикле он ждёт событий от оконной системы и передаёт их через функции обратного вызова, которые мы задали ранее. В нашем случае GLUT будет вызывать только функцию отображения на экран (RenderSceneCB), что бы дать ей возможность нарисовать кадр.__
***
***

__Функция RenderSceneCB__

``` 
static void RenderSceneCB()
{
    ...

``` 
***
```
glClear(GL_COLOR_BUFFER_BIT);
```
_Здесь мы очищаем буфер кадра_
***
```
glEnableVertexAttribArray(0);
```
_Здесь мы разрешаем антрибут индексации для вершин._
***
```
glBindBuffer(GL_ARRAY_BUFFER, VBO);
```
_Здесь мы  привязываем наш буфер, приготавливая его для отрисовки._
***
```
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
```
_Этот вызов говорит конвейеру как воспринимать данные внутри буфера. Первый параметр указывает на индекс атрибута. 
Второй параметр - это количество компонентов в атрибуте (3 для X, Y и Z). 
Третий параметр - тип данных для каждого компонента.
Четвёртый параметр  - хотим ли мы нормализовать атрибуты перед использованием в конвейере. 
Пятый параметр - это показтель того, какое число байтов между 2 экземплярами атрибута. 
Шестой параметр - это смещение в структуре, которую получит наш конвейер._ 
***
```
glDrawArrays(GL_TRIANGLES, 0, 3);
```
_Первый параметр это тип отрисовки. В нашем случае __треугольник__.
Второй параметр - указываем индекс первой верщины в буфере для отрисовки.
Третий параметр - кол-во вершин для отирсовки_
***
```
glutSwapBuffers();
```
Тут мы просим GLUT поменять фоновый буфер и буфер кадра местами.

